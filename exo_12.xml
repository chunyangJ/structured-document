<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="exo.xsl"?>
<exercice id="exo_12">
    <titre>Extraction dans les Fils RSS du Monde</titre>
    <partie titre="XSLT">
        <souspartie titre="Sur les fichiers étiquetés avec treetagger">
            <question id="xslt_1">
                <consignes>
                    <consigne type="simple">Construire une feuille de styles pour afficher les contenus étiquetés avec TreeTagger des rubriques traitées dans le cours Projet (SF vous montrera un exemple...)</consigne>
                </consignes>
                  <reponse type="1-m">
							<note><b>base de travail</b>, le mois du mai de l'arborescence du fils RSS du Monde 2017</note>
							<code langage="markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;xsl:output method="html" encoding="UTF-8" doctype-system="about:legacy-compat" indent="yes"/&gt;
  &lt;!--EXO12_XSLT_Q1 Construire une feuille de styles pour afficher les contenus étiquetés avec TreeTagger des
rubriques traitées dans le cours Projet--&gt;
  &lt;xsl:variable name="rubrique" select="base/@rubrique"/&gt;
  &lt;xsl:variable name="auteur1" select="base/entete/auteur[1]"/&gt;
  &lt;xsl:variable name="auteur2" select="base/entete/auteur[2]"/&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1"/&gt;
        &lt;link rel="stylesheet" href="exo.css"/&gt;
        &lt;title&gt;EXO12_XSLT_Q1&lt;/title&gt;
        &lt;xsl:apply-templates select="base" mode="head"/&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates select="base/etiquetage" mode="contenu"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;!-- entete --&gt;
  &lt;xsl:template match="base[@rubrique]" mode="head"&gt;
    &lt;meta name="auteur" content="{$auteur1}"/&gt;
    &lt;meta name="auteur" content="{$auteur2}"/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="etiquetage" mode="contenu"&gt;
    &lt;div class="header" align="center"&gt;
      &lt;h1&gt;
        &lt;xsl:value-of
          select="concat('Etiquetage du Rubrique-',$rubrique,' du Fils RSS du Monde 2017')"/&gt;
      &lt;/h1&gt;
      &lt;h2&gt;
        &lt;xsl:value-of select="concat('Auteurs : ',$auteur1,', ',$auteur2)"/&gt;
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class="table-wrapper" style="margin-left:auto; margin-right:auto;width:70%"&gt;
      &lt;table class="alt"&gt;
        &lt;tbody&gt;
          &lt;tr style="text-align:center"&gt;
            &lt;td width="30%"&gt;
              &lt;h2&gt;Fichier initial&lt;/h2&gt;
            &lt;/td&gt;
            &lt;td width="70%"&gt;
              &lt;h2&gt;&lt;span class="forme"&gt;Forme&lt;/span&gt;[&lt;span class="lemme"&gt;Lemme&lt;/span&gt;-&lt;span
                  class="pos"&gt;Catégorie&lt;/span&gt;]&lt;/h2&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
          &lt;xsl:apply-templates select="fichier" mode="contenu"/&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="fichier" mode="contenu"&gt;
    &lt;tr style="text-align:left"&gt;
      &lt;td&gt;
        &lt;strong&gt;
          &lt;xsl:value-of select="@nom"/&gt;
        &lt;/strong&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:apply-templates select="element" mode="contenu"/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="element" mode="contenu"&gt;
    &lt;xsl:variable name="pos" select="./data[1]"/&gt;
    &lt;xsl:variable name="lemme" select="./data[2]"/&gt;
    &lt;xsl:variable name="forme" select="./data[3]"/&gt;
    &lt;span class="forme"&gt;
      &lt;xsl:value-of select="$forme"/&gt;
    &lt;/span&gt;
    &lt;xsl:text&gt;[&lt;/xsl:text&gt;
    &lt;span class="lemme"&gt;
      &lt;xsl:value-of select="$lemme"/&gt;
    &lt;/span&gt;
    &lt;xsl:text&gt;-&lt;/xsl:text&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="$pos[contains(.,'SENT')]"&gt;
        &lt;span class="pos"&gt;
          &lt;xsl:value-of select="$pos"/&gt;
        &lt;/span&gt;
        &lt;xsl:text&gt;]
    &lt;/xsl:text&gt;
        &lt;br/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;span class="pos"&gt;
          &lt;xsl:value-of select="$pos"/&gt;
        &lt;/span&gt;
        &lt;xsl:text&gt;] &lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code>
							<resultat fichier="exo12_XSLT_q1_3208.xml" id="3208"/>							
							<resultat fichier="exo12_XSLT_q1_823353.xml" id="823353"/>                
                </reponse>
            </question>
            <question id="xslt_2">
                <consignes>
                    <consigne type="simple">Construire des feuilles de style pour extraire (au format TXT) au moins 3 patrons morpho-syntaxiques (de longueurs différentes) sur les mêmes fichiers</consigne>
                </consignes>
                <reponse type="1-m">
							 <note>q2 écrit des résultats dans des fichiers txt en foction de leur <em>rubrique</em> et <em>motif</em><br/>
								Les résultats <i>infra</i> sont des patrons extraits des <br/>
								<b>rubriques</b> 3208(<b>La Une</b>) et 823353(<b>Politiques</b>) du mois de mai du fils RSS <em>du Monde</em> 2017.<br/>
								<b>Motif</b> : <c>NomAdj</c>, <c>NomPrpNom</c>, <c>NomPrpDetNom</c><br/> 						 
							 </note>              
                		<code langage="markup">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:output method="text" encoding="utf-8"/&gt;
    &lt;!-- exo12_XSLT_q2 Construire des feuilles de style pour extraire (au format TXT) au moins 3 patrons morpho-
syntaxiques (de longueurs différentes) sur les mêmes fichiers --&gt;
    &lt;!--(head -n 1 $nomFic; tail -n +2 $nomFic | sort | uniq -ic | sort -gr) &gt; $nomFicSort--&gt;
    &lt;xsl:template match="/"&gt;
        &lt;xsl:variable name="rubrique" select="base/@rubrique"/&gt;
        &lt;xsl:result-document href="{concat($rubrique,'_NomAdj.txt')}"&gt;
            &lt;xsl:text&gt;----------------Nom Adj-------------------
&lt;/xsl:text&gt;
            &lt;xsl:apply-templates select="base/etiquetage/fichier/element" mode="NomAdj"/&gt;
        &lt;/xsl:result-document&gt;
        &lt;xsl:result-document href="{concat($rubrique,'_NomPrpNom.txt')}"&gt;
            &lt;xsl:text&gt;----------------Nom Prp Nom-------------------
&lt;/xsl:text&gt;
            &lt;xsl:apply-templates select="base/etiquetage/fichier/element" mode="NomPrpNom"/&gt;
        &lt;/xsl:result-document&gt;

        &lt;xsl:result-document href="{concat($rubrique,'_NomPrpDetNom.txt')}"&gt;
            &lt;xsl:text&gt;----------------Nom Prp Det Nom-------------------
&lt;/xsl:text&gt;
            &lt;xsl:apply-templates select="base/etiquetage/fichier/element" mode="NomPrpDetNom"/&gt;
        &lt;/xsl:result-document&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="element" mode="NomAdj"&gt;
        &lt;xsl:variable name="ele1" select="."/&gt;
        &lt;xsl:variable name="ele2" select="following-sibling::element[1]"/&gt;
        &lt;xsl:if test="($ele1/data[1]='NOM') and ($ele2/data[1]='ADJ')"&gt;
            &lt;xsl:value-of select="concat($ele1/data[3],' ',$ele2/data[3])"/&gt;
            &lt;xsl:text&gt;
&lt;/xsl:text&gt;
        &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="element" mode="NomPrpNom"&gt;
        &lt;xsl:variable name="ele1" select="."/&gt;
        &lt;xsl:variable name="ele2" select="following-sibling::element[1]"/&gt;
        &lt;xsl:variable name="ele3" select="following-sibling::element[2]"/&gt;
        &lt;xsl:if
            test="($ele1/data[1]='NOM') and ($ele2/data[1][matches(.,'PRP')]) and ($ele3/data[1]='NOM')"&gt;
            &lt;xsl:value-of select="concat($ele1/data[3],' ',$ele2/data[3],' ',$ele3/data[3])"/&gt;
            &lt;xsl:text&gt;
&lt;/xsl:text&gt;
        &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="element" mode="NomPrpDetNom"&gt;
        &lt;xsl:variable name="ele1" select="."/&gt;
        &lt;xsl:variable name="ele2" select="following-sibling::element[1]"/&gt;
        &lt;xsl:variable name="ele3" select="following-sibling::element[2]"/&gt;
        &lt;xsl:variable name="ele4" select="following-sibling::element[3]"/&gt;
        &lt;xsl:variable name="ele5" select="following-sibling::element[4]"/&gt;
        &lt;xsl:if
            test="($ele1/data[1]='NOM') and ($ele2/data[1][contains(.,'PRP')]) and ($ele3/data[1][contains(.,'DET')]) and ($ele4/data[1]='NOM')"&gt;
            &lt;xsl:value-of
                select="concat($ele1/data[3],' ',$ele2/data[3],' ',$ele3/data[3],' ',$ele4/data[3])"/&gt;
            &lt;xsl:text&gt;
&lt;/xsl:text&gt;
        &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;

</code>
							<resultat fichier="exo12_XSLT_q2_823353_NomAdj_sort.txt" id="823353-NA"/>
							<resultat fichier="exo12_XSLT_q2_3208_NomAdj_sort.txt" id="3208-NA"/>
							<resultat fichier="exo12_XSLT_q2_823353_NomPrpNom_sort.txt" id="823353-NPN"/>
							<resultat fichier="exo12_XSLT_q2_3208_NomPrpNom_sort.txt" id="3208-NPN"/>
							<resultat fichier="exo12_XSLT_q2_3208_NomPrpDetNom_sort.txt" id="3208-NPDN"/>
							  
                </reponse>
            </question>
            <question id="xslt_3">
                <consignes>
                    <consigne type="simple">Construire une feuille de styles pour afficher les contenus étiquetés avec TreeTagger des rubriques traitées dans le cours Projet en mettant au jour un patron morphosyntaxique.</consigne>
                </consignes>
                <reponse type="1-m">
							<note>
								<b>rubriques</b> 3208(<b>La Une</b>) et 823353(<b>Politiques</b>) du mois de mai du fils RSS <em>du Monde</em> 2017.<br/>
								<b>Motif</b> : <c>NomPrpNom</c><br/>							
							</note>
							<code langage="markup">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;
  &lt;!-- Construire une feuille de styles pour afficher les contenus étiquetés avec TreeTagger des
rubriques traitées dans le cours Projet en mettant au jour un patron morphosyntaxique. NOM PRP NOM --&gt;
  &lt;xsl:output method="html" encoding="UTF-8" doctype-system="about:legacy-compat" indent="yes"/&gt;
  &lt;xsl:variable name="rubrique" select="base/@rubrique"/&gt;
  &lt;xsl:variable name="auteur1" select="base/entete/auteur[1]"/&gt;
  &lt;xsl:variable name="auteur2" select="base/entete/auteur[2]"/&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1"/&gt;
        &lt;link rel="stylesheet" href="exo.css"/&gt;
        &lt;title&gt;EXO12_XSLT_Q3&lt;/title&gt;
        &lt;xsl:apply-templates select="base" mode="head"/&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;xsl:apply-templates select="base/etiquetage" mode="contenu"/&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;
  &lt;!-- entete --&gt;
  &lt;xsl:template match="base[@rubrique]" mode="head"&gt;
    &lt;meta name="auteur" content="{$auteur1}"/&gt;
    &lt;meta name="auteur" content="{$auteur2}"/&gt;
  &lt;/xsl:template&gt;
  &lt;!--contenu--&gt;
  &lt;xsl:template match="etiquetage" mode="contenu"&gt;
    &lt;div class="header" align="center"&gt;
      &lt;h1&gt;
        &lt;xsl:value-of
          select="concat('Rubrique-',$rubrique,' du Fils RSS du Monde 2017')"
        /&gt;
      &lt;/h1&gt;
      &lt;h2&gt;&lt;xsl:text&gt;Les séquences NOM PRP NOM&lt;/xsl:text&gt;&lt;/h2&gt;
      &lt;h2&gt;
        &lt;xsl:value-of select="concat('Auteurs : ',$auteur1,', ',$auteur2)"/&gt;
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class="table-wrapper" style="margin-left:auto; margin-right:auto;width:70%"&gt;
      &lt;table class="alt"&gt;
        &lt;tbody&gt;
          &lt;tr style="text-align:center"&gt;
            &lt;td width="30%"&gt;
              &lt;h2&gt;Fichier initial&lt;/h2&gt;
            &lt;/td&gt;
            &lt;td width="70%"&gt;
              &lt;h2&gt;&lt;span class="forme"&gt;Forme&lt;/span&gt;[&lt;span class="lemme"&gt;Lemme&lt;/span&gt;-&lt;span
                  class="pos"&gt;Catégorie&lt;/span&gt;]&lt;/h2&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
          &lt;xsl:apply-templates select="fichier" mode="contenu"/&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="fichier" mode="contenu"&gt;
    &lt;tr style="text-align:left"&gt;
      &lt;td&gt;
        &lt;strong&gt;
          &lt;xsl:value-of select="@nom"/&gt;
        &lt;/strong&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:apply-templates select="element" mode="contenu"/&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="element" mode="contenu"&gt;
    &lt;xsl:variable name="ele1" select="."/&gt;
    &lt;xsl:variable name="pos" select="./data[1]"/&gt;
    &lt;xsl:variable name="lemme" select="./data[2]"/&gt;
    &lt;xsl:variable name="forme" select="./data[3]"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when
        test="($ele1/data[1]='NOM') and (following-sibling::element[1]/data[1][contains(.,'PRP')]) and (following-sibling::element[2]/data[1]='NOM')"&gt;
        &lt;span class="forme"&gt;
          &lt;mark&gt;
            &lt;xsl:value-of select="$forme"/&gt;
          &lt;/mark&gt;
        &lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when
        test="($ele1/data[1][contains(.,'PRP')]) and (preceding-sibling::element[1]/data[1]='NOM') and (following-sibling::element[1]/data[1]='NOM')"&gt;
        &lt;span class="forme"&gt;
          &lt;mark&gt;
            &lt;xsl:value-of select="$forme"/&gt;
          &lt;/mark&gt;
        &lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when
        test="($ele1/data[1]='NOM') and (preceding-sibling::element[1]/data[1][contains(.,'PRP')]) and (preceding-sibling::element[2]/data[1]='NOM')"&gt;
        &lt;span class="forme"&gt;
          &lt;mark&gt;
            &lt;xsl:value-of select="$forme"/&gt;
          &lt;/mark&gt;
        &lt;/span&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;span class="forme"&gt;
          &lt;xsl:value-of select="$forme"/&gt;
        &lt;/span&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:text&gt;[&lt;/xsl:text&gt;
    &lt;span class="lemme"&gt;
      &lt;xsl:value-of select="$lemme"/&gt;
    &lt;/span&gt;
    &lt;xsl:text&gt;-&lt;/xsl:text&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="$pos[contains(.,'SENT')]"&gt;
        &lt;span class="pos"&gt;
          &lt;xsl:value-of select="$pos"/&gt;
        &lt;/span&gt;
        &lt;xsl:text&gt;]
    &lt;/xsl:text&gt;
        &lt;br/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;span class="pos"&gt;
          &lt;xsl:value-of select="$pos"/&gt;
        &lt;/span&gt;
        &lt;xsl:text&gt;] &lt;/xsl:text&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code>
							<resultat fichier="exo12_XSLT_q3_3208.xml" id="3208-NomPrpNom"/>
							<resultat fichier="exo12_XSLT_q3_823353.xml" id="823353-NomPrpNom"/>                
                </reponse>
            </question>
        </souspartie>
    </partie>
    <partie titre="XQuery (via BASEX)">
        <souspartie titre="Sur les fils RSS de l’ensemble du corpus">
            <question id="xqrss_1">
                <consignes>
                    <consigne type="simple">
                    Construire une requête pour extraire les contenus textuels des titres
                    </consigne>
                </consignes>
                <note><b>base de travail</b>, l'ensemble du fils RSS ;<br/>
                <b>rubriques</b> 3208(<b>La Une</b>) et 823353(<b>Politiques</b>).
		Les résultats sont produits en xml, et sont transformés à l'aide de feuilles de style</note>
                <reponse type="code-resultat">
                	<code langage="markup">(:exo_12_XQuery_RSS_q1 Sur les fils RSS de l’ensemble du corpus, construire une requête pour extraire les contenus textuels des titres:)
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:omit-xml-declaration "no";
&lt;base nom="fils RSS du Monde 2017"&gt;
{
  let $channel:=collection("RSSMONDE2017")/rss/channel
  for $item at $pos in $channel/item
    let $title:=$item/title/text()
    return &lt;description id="{$pos}"&gt;{$title}&lt;/description&gt;
}
&lt;/base&gt;

</code>
               	 <resultat fichier="exo12_XQuery_RSS_q1.xml"/>
                </reponse>
                
            </question>
            <question id="xqrss_2">
                <consignes>
                    <consigne type="simple">
                    Construire une requête pour extraire les contenus textuels des descriptions
                    </consigne>
                </consignes>
                <reponse type="code-resultat">
                		<code langage="markup">(:exo_12_XQuery_RSS_q2 Sur les fils RSS de l’ensemble du corpus, construire une requête pour extraire les contenus textuels des descriptions:)
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:omit-xml-declaration "no";
&lt;base nom="fils RSS du Monde 2017"&gt;
{
  let $channel:=collection("RSSMONDE2017")/rss/channel
  for $item at $pos in $channel/item
    let $des:=$item/description/text()
    return &lt;description id="{$pos}"&gt;{$des}&lt;/description&gt;
}
&lt;/base&gt;
</code>
               	 	<resultat fichier="exo12_XQuery_RSS_q2.xml"/>
                </reponse>
            </question>
            <question id="xqrss_3">
                <consignes>
                    <consigne type="simple">
                    Construire une requête pour extraire les contenus textuels des titres ET des descriptions
                    </consigne>
                </consignes>
                <reponse type="code-resultat">
                		<code langage="markup">(:exo_12_XQuery_RSS_q3 Sur les fils RSS de l’ensemble du corpus, construire une requête pour extraire les contenus textuels des titres ET des descriptions:)
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:omit-xml-declaration "no";
&lt;base nom="fils RSS du Monde 2017"&gt;
{
  let $channel:=collection("RSSMONDE2017")/rss/channel
  for $item at $pos in $channel/item
    let $title:=$item/title
    let $des:=$title/following-sibling::description
    return &lt;item id="{$pos}"&gt;{&lt;titre&gt;{$title/text()}&lt;/titre&gt;,&lt;description&gt;{$des/text()}&lt;/description&gt;}&lt;/item&gt;
}
&lt;/base&gt;</code>
               	 	<resultat fichier="exo12_XQuery_RSS_q3.xml"/>
                </reponse>
            </question>
        </souspartie>
        <souspartie titre="Sur les fichiers étiquetés avec treetagger (par rubrique a priori)">
            <question id="xqtag_1">
                <consignes>
                    <consigne type="simple">
                    Construire une requête pour extraire les patrons morpho-syntaxiques NOM ADJ
                    </consigne>
                </consignes>
                <reponse type="1-m">
						<note><b>base de travail</b>, même que celle des questions XSLT<br/>
						<b>motif</b> : <c>NomAdj</c>
						Les résultats sont écrits respectivement dans des fichiers xml nommés par rubrique et motif<br/>
						Ces fichiers xml sont ensuite transformés par feuille de style.
						</note>
						<code langage="markup">(:exo_12_XQuery_TREETAGGER_q1 Sur les fichiers étiquetés avec treetagger (par rubrique a priori), Construire une requête pour extraire les patrons morpho-syntaxiques NOM ADJ:)
(:les patrons sont écrits respectivement dans des fichiers nommés par rubrique:)
   let $base := collection("SAMPLETREETAGGER")/base
   for $rubrique in distinct-values($base/@rubrique)
   let $fName := concat("./Patrons/", $rubrique, "_NOMADJ.xml")
   let $params := &lt;output:serialization-parameters xmlns:output="http://www.w3.org/2010/xslt-xquery-serialization"&gt;
   &lt;output:method value='xml'/&gt;
  &lt;output:omit-xml-declaration value="no"/&gt;
&lt;/output:serialization-parameters&gt;
   return 
     file:write($fName,
       &lt;patrons rubrique="{$rubrique}" type="NOM ADJ"&gt;
       {
         for $ele1 in $base[@rubrique=$rubrique]/etiquetage/fichier/element
         let $ele2 := $ele1/following-sibling::element[1]
         where $ele1/data[1]="NOM" and $ele2/data[1]="ADJ"
         return &lt;patron&gt;{$ele1/data[3]/text()," ", $ele2/data[3]/text()}&lt;/patron&gt;
       }
       &lt;/patrons&gt;, $params)
   </code>
						<resultat fichier="exo12_XQuery_TREETAGGER_q1_3208_NOMADJ.xml" id="3208-NomAdj"/>
						<resultat fichier="exo12_XQuery_TREETAGGER_q1_823353_NOMADJ.xml" id="823353-NomAdj"/>           
                </reponse>
            </question>
            <question id="xqtag_2">
                <consignes>
                    <consigne type="simple">
                    Construire une requête pour extraire les patrons morpho-syntaxiques NOM PRP NOM
                    </consigne>
                </consignes>
                <reponse type="1-m">
							<code langage="markup">(:exo_12_XQuery_TREETAGGER_q2 Sur les fichiers étiquetés avec treetagger (par rubrique a priori), Construire une requête pour extraire les patrons morpho-syntaxiques NOM PRP NOM:)
(:les patrons sont écrits respectivement dans des fichiers nommés par rubrique:)
   let $base := collection("SAMPLETREETAGGER")/base
   for $rubrique in distinct-values($base/@rubrique)
   let $fName := concat("./Patrons/", $rubrique, "_NOMPRPNOM.xml")
   let $params := &lt;output:serialization-parameters xmlns:output="http://www.w3.org/2010/xslt-xquery-serialization"&gt;
   &lt;output:method value='xml'/&gt;
  &lt;output:omit-xml-declaration value="no"/&gt;
&lt;/output:serialization-parameters&gt;
   return 
     file:write($fName,
       &lt;patrons rubrique="{$rubrique}" type="NOM PRP NOM"&gt;
       {
         for $ele1 in $base[@rubrique=$rubrique]/etiquetage/fichier/element
         let $ele2 := $ele1/following-sibling::element[1]
         let $ele3 := $ele1/following-sibling::element[2]
         where $ele1/data[1]="NOM" and $ele2/data[1][matches(.,"PRP")] and $ele3/data[1]="NOM"
         return &lt;patron&gt;{$ele1/data[3]/text()," ", $ele2/data[3]/text()," ", $ele3/data[3]/text()}&lt;/patron&gt;
       }
       &lt;/patrons&gt;, $params)
</code>
							<resultat fichier="exo12_XQuery_TREETAGGER_q2_3208_NOMPRPNOM.xml" id="3208-NomAdj"/>
							<resultat fichier="exo12_XQuery_TREETAGGER_q2_823353_NOMPRPNOM.xml" id="823353-NomPrpNom"/>          
                
                </reponse>
            </question>
        </souspartie>
    </partie>
    <appendice>
       <fichier src="XSLT.zip" type="XSLT" />
        <fichier src="XQUERY.zip" type="XQUERY" />
    </appendice>
</exercice>